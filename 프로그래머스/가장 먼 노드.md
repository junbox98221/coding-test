# [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)

1번 노드에서 각 노드별로 최단 거리로 이동했을 때 가장 먼 노드의 개수를 반환하는 문제이다.

해당 노드를 처음 방문한다면 현재의 depth를, 방문했다면 기존과 depth를 비교하여 갱신한다.

```js
function solution(n, edge) {
    const visited = { 1: true };
    const vertexs = {};

    // 노드별 방문 가능한 노드 탐색
    for ([start, end] of edge) {
        vertexs[start] = [...(vertexs[start] || []), end];
        vertexs[end] = [...(vertexs[end] || []), start];
    }

    const depths = Array(n + 1).fill(0);
    const queue = [];
    // bfs로 순회하며 현재 depth를 관리한다.
    queue.push([0, 1]); // [node, depth]

    while (queue.length > 0) {
        const [cDepth, cNode] = queue.shift();

        const nDepth = cDepth + 1;

        // 현재 노드에서 방문 가능한 노드 순회
        for (let nNode of vertexs[cNode]) {
            // 방문헀다면, depth 비교
            if (visited[nNode]) {
                depths[nNode] = Math.min(depths[nNode], nDepth);
            } else {
                // 방문하지 않았다면, queue에 추가 및 방문, 깊이 저장
                queue.push([nDepth, nNode]);
                visited[nNode] = true;
                depths[nNode] = nDepth;
            }
        }
    }

    const maxDepth = Math.max(...depths);
    return depths.filter((depth) => depth === maxDepth).length;
}
```
