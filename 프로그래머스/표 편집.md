# [표 편집](https://school.programmers.co.kr/learn/courses/30/lessons/81303)

요소가 나열된 리스트에서 요소를 선택, 삭제, 복구하는 명령어들을 실행한 뒤, 최종 상태를 반환하는 문제이다.

각 요소를 이중 연결 리스트로 표현하고, 삭제된 행은 스택에 저장하여 복구하는 방식으로 풀이한다.

총 4개의 명령어에 대한 함수를 구현하면 된다.

함수 하나하나의 구혀 난이도는 높지 않지만, 요구사항을 정확하게 구혀하는 것이 중요하다.1

```js
let list = []; // isAlive, prev, next
const stack = []; // k, prev, next

const up = (index, count) => {
  while (count-- > 0 && list[index][1] !== -1) index = list[index][1]; // count만큼 위로 이동. 단, 맨 위에 도달하면 멈춤
  return index;
};

const down = (index, count) => {
  while (count-- > 0 && list[index][2] !== -1) index = list[index][2]; // count만큼 아래로 이동. 단, 맨 아래에 도달하면 멈춤
  return index;
};

const remove = (index) => {
  const [isAlive, prev, next] = list[index];
  list[index][0] = false;

  // 삭제한 행 위, 아래의 행을 연결시켜줌
  if (prev !== -1) list[prev][2] = next;
  if (next !== -1) list[next][1] = prev;

  stack.push([index, prev, next]);

  // 다음 행이 없으면 위의 행을 선택
  return next !== -1 ? next : prev;
};

const restore = () => {
  const [index, prev, next] = stack.pop();

  if (prev !== -1) list[prev][2] = index;
  if (next !== -1) list[next][1] = index;

  list[index][0] = true;
};

function solution(n, k, cmds) {
  list = Array.from({ length: n }, (_, index) => [true, index - 1, index + 1]);
  list[list.length - 1][2] = -1;

  for (let cmd of cmds) {
    const [c, count] = cmd.split(" ");

    switch (c) {
      case "D":
        k = down(k, count);
        break;
      case "U":
        k = up(k, count);
        break;
      case "Z":
        restore(k);
        break;
      case "C":
        k = remove(k);
        break;
    }
  }

  return list
    .map((item) => item[0])
    .reduce((prev, isAlive) => (isAlive ? prev + "O" : prev + "X"), "");
}
```
