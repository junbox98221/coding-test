# [자물쇠와 열쇠](https://school.programmers.co.kr/learn/courses/30/lessons/60059)

열쇠를 회전, 이동시켜서 자물쇠에 일치시킬 수 있는지 반환하는 문제다.

열쇠, 자물쇠가 최대 길이 20인 2차원 배열이기 때문에 완전탐색으로 풀 수 있다.

## 탐색에 고려해야 하는 조건

### 1. 열쇠의 이동

- 열쇠가 자물쇠를 벗어나게 이동할 수 있으니 (자물쇠 길이) + (열쇠 길이 x 2) 로 확장한 이중 배열 중간에 자물쇠 배치
- 모든 위치에 열쇠를 두기

### 2. 열쇠의 회전

- 4방향 회전시켜 4개의 열쇠 테스트

2가지 조건을 고려하여 탐색을 하면 된다.

```js
// 열쇠를 회전하는 함수
function rotate(matrix) {
  const n = matrix.length;
  const result = Array.from({ length: n }, () => Array(n).fill(0));

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      result[j][n - 1 - i] = matrix[i][j];
    }
  }
  return result;
}

// 모든 자물쇠 영역이 채워졌는지 확인
function check(newLock, lockSize, keySize) {
  for (let i = 0; i < lockSize; i++) {
    for (let j = 0; j < lockSize; j++) {
      if (newLock[i + keySize - 1][j + keySize - 1] !== 1) {
        return false;
      }
    }
  }
  return true;
}

function solution(key, lock) {
  const m = key.length;
  const n = lock.length;

  // 자물쇠 길이 + (키 길이 * 2) 의 새로운 자물쇠 생성
  const newSize = n + 2 * (m - 1);
  const newLock = Array.from({ length: newSize }, () => Array(newSize).fill(0));

  // 자물쇠를 중앙에 배치
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      newLock[i + m - 1][j + m - 1] = lock[i][j];
    }
  }

  // 4방향 회전한 키에 대해서 탐색
  for (let rotation = 0; rotation < 4; rotation++) {
    key = rotate(key);

    // 모든 위치에 대해서 탐색
    for (let x = 0; x <= newSize - m; x++) {
      for (let y = 0; y <= newSize - m; y++) {
        // 회전한 열쇠를 덮기
        for (let i = 0; i < m; i++) {
          for (let j = 0; j < m; j++) {
            newLock[x + i][y + j] += key[i][j];
          }
        }

        // 자물쇠가 열리는지 확인
        if (check(newLock, n, m)) return true;

        // 열쇠 제거
        for (let i = 0; i < m; i++) {
          for (let j = 0; j < m; j++) {
            newLock[x + i][y + j] -= key[i][j];
          }
        }
      }
    }
  }

  return false;
}
```
