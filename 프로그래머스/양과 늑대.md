# [양과 늑대](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

양과 늑대가 있는 트리 구조에서 양을 최대로 모으는 문제이다.

처음에는 stack + while문 조합으로 dfs를 구현하려 했다.

하지만 while문 외부에 양, 늑대, visited 변수를 둬서 분기 간 상태가 섞이는 문제가 발생했다.

따라서 dfs를 재귀로 구현하여 각 분기마다 상태가 독립적으로 유지되도록 하였다.

그리고, 지금까지 방문한 노드의 다음 자식 노드들을 방문 가능한 후보로 관리하며 dfs를 실행하는 방식으로 풀이하였다.

```js
function solution(info, edges) {
  const graph = Array.from({ length: info.length }, () => []);

  for (let [start, end] of edges) {
    // 방문 가능한 자식 그래프 생성
    graph[start].push(end);
  }

  let answer = 0;

  // 현재 노드, 지금까지 모은 양, 지금까지 만난 늑대, 방문 가능한 노드
  const dfs = (node, sheep, wolf, possibles) => {
    const character = info[node];

    if (character === 1) wolf++;
    else sheep++;

    if (wolf >= sheep) return;
    answer = Math.max(sheep, answer);

    const newPossibles = [...possibles];
    newPossibles.push(...graph[node]);
    newPossibles.splice(possibles.indexOf(node), 1); // 현재 노드 방문 처리

    // 방문 가능한 노드들에 대해 dfs 실행
    for (let nextNode of newPossibles) {
      dfs(nextNode, sheep, wolf, newPossibles.slice());
    }
  };

  dfs(0, 0, 0, [0]);

  return answer;
}
```
