# [징검다리 건너기](https://school.programmers.co.kr/learn/courses/30/lessons/860532)

금, 은을 운반하는 최소 시간을 얻는 문제이다.

## 이진 탐색의 기준

시간 T 동안 옮길 수 있는지 판정한다.

## 시간안에 완료할 수 있는지 판단하는 방법

도시별 운반 가능 총량은 다음과 같다.

- trips : 운반 가능 횟수
- 총 적재량: cap = trips \* 최대 운반 무게
- 금 최대: min(g[i], cap)
- 은 최대: min(s[i], cap)
- 금+은 최대: min(g[i] + s[i], cap)

이를 통해 모든 도시의 최대 운반량을 합쳐 아래 3가지 조건이 충족되면 된다.

총 금 운반 가능 총량 >= 금 요구 무게

총 은 운반 가능 총량 >= 은 요구 무게

총 금,은 운반 가능 총량 >= 금,은 요구 무게

```js
function solution(a, b, g, s, w, t) {
  let answer = 10e5 * 4 * 10e9;
  let start = 0;
  let end = 10e5 * 4 * 10e9;

  while (start <= end) {
    let mid = Math.floor((start + end) / 2);
    let gold_carry = 0;
    let silver_carry = 0;
    let all_carry = 0;

    for (let i = 0; i < g.length; i++) {
      let now_gold = g[i];
      let now_silver = s[i];
      let now_w = w[i];
      let now_t = t[i];
      let move_t = Math.floor(mid / (now_t * 2)); //운반 가능 횟수
      if (mid % (now_t * 2) >= now_t) move_t++;

      //금만 캤을때
      gold_carry += move_t * now_w >= now_gold ? now_gold : move_t * now_w;
      //은만 캤을때
      silver_carry +=
        move_t * now_w >= now_silver ? now_silver : move_t * now_w;

      //최대로 옮길 때
      all_carry +=
        move_t * now_w >= now_silver + now_gold
          ? now_silver + now_gold
          : move_t * now_w;
    }
    if (a <= gold_carry && b <= silver_carry && a + b <= all_carry) {
      end = mid - 1;
      answer = Math.min(answer, mid);
    } else {
      start = mid + 1;
    }
  }
  return answer;
}
```
