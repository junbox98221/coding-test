# [사라지는 발판](https://school.programmers.co.kr/learn/courses/30/lessons/92345?language=javascript)

DFS + 백트래킹 + 이동 횟수 판정으로 풀어야 하는 문제다.

## 1. DFS

dfs를 통해 각 플레이어가 턴을 번갈아가며 **최적의 플레이를 할 때 이동 수를 반환**한다.

최적의 플레이란,

- 승리 플레이어: 가장 적은 이동으로 승리
- 패배 플레이어: 가장 많은 이동으로 패배

따라서 승,패 여부가 결정되었다면 각각 최소 이동, 최대 이동을 노려야 한다.

## 2. 백트래킹

dfs로 재귀를 돌게 되는데, 사라진 보드 발판은 재귀가 종료되었을 때는 존재하도록 원상복구 시킨다.

그래야 다른 분기를 탐색할 때 정상 상태에서 시작할 수 있다.

## 3. 이동 횟수

dfs로 얻은 이동 횟수가 홀수, 짝수인지에 따라 추구해야 하는 최적 이동 회수는 달라진다.

### 3.1 홀수

현재 차례의 플레이어가 승리한 것을 의미한다. (내가 마지막에 두고 상대는 못 둠)
따라서 빨리 이기도록 **최소 횟수** 선택한다.

### 3.2 짝수

현제 차례의 플레이어가 패배한 것을 의미한다.
늦게 지도록 **최대 횟수** 선택한다.

```JavaScript
// 3,6,9,12시 방향
const dirs = [
  [0, 1],
  [-1, 0],
  [0, -1],
  [1, 0],
];

function solution(board, aloc, bloc) {
  const H = board.length,
    W = board[0].length;

  const out = (y, x) => y < 0 || x < 0 || y >= H || x >= W; // 보드를 이탈헀는지 검사하는 함수

  function dfs(cur, opp) {
    const [y, x] = cur;

    if (!board[y][x]) return 0; // 현재 칸이 이미 사라졌으면 즉시 패배

    board[y][x] = 0; // 현재 칸 제거(백트래킹)

    let winFound = false; // 이길 수 있는 수를 찾았는지
    let minWin = Infinity; // 이기는 수들 중 최소 이동 수
    let maxLose = 0; // 지는 수들 중 최대 이동 수

    // 4개 방향에 대해 탐색
    for (const [dy, dx] of dirs) {
      const ny = y + dy,
        nx = x + dx;
      if (out(ny, nx) || !board[ny][nx]) continue; // 보드를 이탈했거나 발판이 없으면 순회를 건너뜀

      const moves = dfs(opp, [ny, nx]) + 1; // 이동 횟수

      if (moves % 2 === 1) {
        // 이기는 수
        winFound = true;
        if (moves < minWin) minWin = moves; // 최대한 빨리 이기기
      } else {
        // 지는 수
        if (moves > maxLose) maxLose = moves; // 최대한 늦게 지기
      }
    }

    // 복구
    board[y][x] = 1;

    // 이길 수 있으면 가장 빨리 이기는 수, 아니면 가장 늦게 지는 수
    return winFound ? minWin : maxLose;
  }

  return dfs(aloc, bloc);
}
```
